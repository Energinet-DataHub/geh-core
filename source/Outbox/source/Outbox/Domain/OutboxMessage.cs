// Copyright 2020 Energinet DataHub A/S
//
// Licensed under the Apache License, Version 2.0 (the "License2");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System.ComponentModel.DataAnnotations;
using NodaTime;

namespace Energinet.DataHub.Core.Outbox.Domain;

/// <summary>
/// The outbox domain message
/// The outbox message state flow is like this:
/// 1. From "Created" to Processing
/// 2. From Processing to either Processed or Failed
///
/// If the message is in Failed state, it will be retried after some time, depending on the error count (minimum <see cref="MinimumDurationBetweenFailedAttempts"/>).
/// If the message is stuck in Processing state, it will be retried after some time (<see cref="DurationBetweenProcessingAttempts"/>).
/// </summary>
public sealed class OutboxMessage
{
    public static readonly Duration MinimumDurationBetweenFailedAttempts = Duration.FromMinutes(1);

    public static readonly Duration DurationBetweenProcessingAttempts = Duration.FromMinutes(5);

    public OutboxMessage(
        Instant createdAt,
        string type,
        string payload)
    {
        Id = new OutboxMessageId(Guid.NewGuid());
        CreatedAt = createdAt;
        Type = type;
        Payload = payload;
        ErrorCount = 0;
    }

    public OutboxMessageId Id { get; }

    /// <summary>
    /// RowVersion is generated by the database and used for optimistic concurrency. Must be retrieved when loading
    /// the entity from the database, since Entity Framework uses it to throw an exception if the entity has been updated.
    /// </summary>
    [Timestamp]
    public byte[]? RowVersion { get; }

    public string Type { get; }

    public string Payload { get; }

    public Instant CreatedAt { get; }

    public Instant? ProcessingAt { get; private set; }

    public Instant? PublishedAt { get; private set; }

    public Instant? FailedAt { get; private set; }

    public string? ErrorMessage { get; private set; }

    public int ErrorCount { get; set; }

    public bool IsProcessed => PublishedAt != null;

    /// <summary>
    /// Check if the outbox message should process. Uses both the ProcessingAt and FailedAt properties to determine
    /// if the message should be processed, since a message can be skipped if it is already processing or has failed recently.
    /// </summary>
    public bool ShouldProcessNow(IClock clock)
    {
        ArgumentNullException.ThrowIfNull(clock);

        if (IsProcessed)
            throw new InvalidOperationException($"Should not try to process a message that is already processed (Id = {Id})");

        var readyToProcess = IsReadyToProcess(clock);
        var readyToRetry = IsReadyToRetry(clock);

        return readyToProcess && readyToRetry;
    }

    /// <summary>
    /// Set the outbox message as processing. Will fail if the message is already processed or not ready to be processed.
    /// </summary>
    public void SetAsProcessing(IClock clock)
    {
        ArgumentNullException.ThrowIfNull(clock);

        if (IsProcessed)
            throw new InvalidOperationException($"Cannot set outbox message as processing when already processed (Id = {Id})");

        if (!IsReadyToProcess(clock))
            throw new InvalidOperationException($"Cannot set outbox message as processing when not ready to process (Id = {Id})");

        ProcessingAt = clock.GetCurrentInstant();
    }

    /// <summary>
    /// Set the outbox message as processed. Will fail if the message is already processed.
    /// </summary>
    public void SetAsProcessed(IClock clock)
    {
        ArgumentNullException.ThrowIfNull(clock);

        if (IsProcessed)
            throw new InvalidOperationException($"Cannot set outbox message as processed when already processed (Id = {Id})");

        PublishedAt = clock.GetCurrentInstant();
    }

    /// <summary>
    /// Set the outbox message as failed. Will fail if the message is already processed.
    /// </summary>
    public void SetAsFailed(IClock clock, string errorMessage)
    {
        ArgumentNullException.ThrowIfNull(clock);
        ArgumentException.ThrowIfNullOrEmpty(errorMessage);

        if (IsProcessed)
            throw new InvalidOperationException($"Cannot set outbox message as failed when already processed (Id = {Id})");

        FailedAt = clock.GetCurrentInstant();
        ErrorMessage = errorMessage;
        ErrorCount++;
        ProcessingAt = null;
    }

    private bool IsReadyToProcess(IClock clock)
    {
        if (IsProcessed)
            return false;

        if (ProcessingAt == null)
            return true;

        var processAgainAt = ProcessingAt.Value.Plus(DurationBetweenProcessingAttempts);

        var now = clock.GetCurrentInstant();
        return now >= processAgainAt;
    }

    private bool IsReadyToRetry(IClock clock)
    {
        if (IsProcessed)
            return false;

        if (FailedAt == null)
            return true;

        var errorRetryTimeout = ErrorCount switch
        {
            < 5 => MinimumDurationBetweenFailedAttempts,
            < 10 => Duration.FromHours(1),
            _ => Duration.FromDays(1),
        };

        var retryAgainAt = FailedAt.Value.Plus(errorRetryTimeout);

        var now = clock.GetCurrentInstant();
        return now >= retryAgainAt;
    }
}
